## 一、RBAC模型

RBAC模型有两种解释：

### 1. 基于角色的访问控制（Role based access control）

​		基于角色的访问控制是以角色为中心的，也就是判断用户属于哪个角色来判断是否拥有权限。比如当我们访问删除用户的接口时先判断一下我们是否是ADMIN角色，是就放行，否则拒绝访问。这种方法实现简单但有很多不足，比如我们无法直接修改某个角色的权限（需要修改源代码），无法增加新的角色等等

### 2. 基于资源的访问控制（Resource based access control）

​		基于资源的访问控制是以权限为中心的，也就是判断用户是否拥有访问该资源的权限来判断是否放行。比如当我们访问删除用户的接口时判断我们是否拥有用户表的删除权限，是就放行，否则拒绝访问。这种方法可扩展性强，可以实时修改角色的权限（依旧需要使用角色表来连接用户与权限，可扩展性强），也可以添加新的角色。



## 二、认证模式

### 1. 用户名密码模式

​		用户名密码模式就是用户将账号密码提交到服务器后认证服务器会判断账号密码是否匹配，是就生成令牌返回给用户，用户以后的每一次访问都会携带该令牌，令牌即用户。

### 2. 短信验证码模式

​		短信验证码同用户名密码模式是一致的，只不过此时的密码变成了验证码而已，原理一致。

### 3. 授权码模式

​		授权码模式即第三方登录，用户选择使用第三方应用登录，跳转到第三方授权页面，授权成功后第三方应用返回给用户授权码，用户将授权码提交给认证服务器，认证服务器使用授权码从第三方应用获取用户信息，然后生成令牌返回给用户。

> 1. 



## 三、令牌

### 1. 普通 token 令牌

​		普通 token 令牌就是一串随机字符串，我们将它与用户id 存入 redis 中就可以实现用户与令牌的绑定了。但是在以后的每一次访问中都要进行数据库的查询操作

### 2. Jwt （Json web token）令牌

​		Jwt 令牌本身就可以包含用户信息，服务器收到令牌后对其解析就可以知道访问的用户是谁了，此时令牌可以不用存储在数据库中。缺点是令牌泄漏或用户更改密码时无法实时让以前的token过期，存在一定的安全隐患。解决办法之一是将该token也存入redis中，以后每一次访问都先查询该令牌是否存在于redis中，用户退出登录或修改密码时需要删除redis中的令牌。此时与普通token的区别是普通token获取用户信息是通过查询数据库的操作，而Jwt 令牌获取用户信息是通过解析 Jwt令牌的操作。

> **疑问**：当通过基于资源的访问控制时，用户权限保存在哪里？普通 token无法保存，也就是说每一次访问接口时都要先从redis获取用户id，再以用户id从 Mysql 中获取用户权限，似乎很复杂！！！ 如果使用Jwt 封装用户权限，那么一般用户的权限会有很多，此时Jwt就变得很大了，此时就会很耗费资源！！！

