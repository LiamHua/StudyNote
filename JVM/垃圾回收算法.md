## JVM垃圾回收算法

### 1. 标记-清除算法

​	标记清除顾名思义是一种分两阶段对对象进行垃圾回收的算法。

​	第一阶段：标记。从根结点出发遍历（深度优先）对象，对可访问的对象打上标记，表示该对象可达。

​	第二阶段：清除。对那些没有标记的对象进行回收，这样使得不能利用的空间能够重新被利用。

![image-20200818163423494](https://pictures.huazai.fun/uPic/image-20200818163423494.png)

> 优点：实现简单
>
> 缺点：碎片化严重、效率低（多次遍历）



### 2. 复制算法

​		复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就==将还存活着的对象复制到另外一块上面==，然后再把已使用过的内存空间一次清理掉。这个算法解决了标记-清除算法的很多缺点，对整个半区回收解决了碎片问题，而且在新生代中只有少量的存活对象需要我们去标记，效率高。

![image-20200818163448329](https://pictures.huazai.fun/uPic/image-20200818163448329.png)

> 优点：解决了碎片问题、当存活对象少时效率高
>
> 缺点：可用内存缩水为原来的一半、当存活对象过多时效率变低



### 3. 标记-整理算法

​		标记整理算法与标记清除算法相同的是标记阶段，不同的是标记后它会将所有存活对象向内存一端移动，然后清理掉边界以外的内存，以解决碎片化问题，后果就是对象移动也是一个费资源的操作

![image-20200818164236013](https://pictures.huazai.fun/uPic/image-20200818164236013.png)

> 优点：解决了碎片化问题
>
> 缺点：负重大



### 4. 总结

+ 新生代存活对象少，因此常采用复制算法来回收垃圾，既解决了碎片问题，效率也高
+ 复制算法是将内存空间对半分，但实际上由于新生代 一般存活对象远少于死亡对象，
+ 老年代存活对象多，不适合用复制算法，可采用标记清除算法或标记整理算法，部分虚拟机采用标记清除算法，然后当碎片过多影响内存分配时，再采用标记整理算法来回收一次以整理内存空间