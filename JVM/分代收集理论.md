## 分代收集理论

### 1. 概述

​		收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用

​		在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算法”“标记-整理算法”等针对性的垃圾收集算法



### 2. 划分

​		一般划分为新生代和老年代两个区域，在新生代中，每次垃圾回收都会有大量的对象死去，而存活的少量对象就会逐步进入老年代中存放。新生代与老年代的大小比例为1:2（不固定，视具体情况查看），其中新生代中又分为 1 个Eden区和 2 个Survivor区，比例为 8:1:1。

​		首先我们来探讨一下新生代为什么要划分为三个区？第一个疑问就是如果不划分会怎样，如果新生代不分区的话那么在经过 Minor GC 后存活的对象就会直接进入老年代，导致老年代空间很快被填满而执行 Major GC，而因为老年代空间比新生代空间大所以 Major GC 的时间比 Minor GC 时间长（或许还得研究一下所用算法的时间比较），所以效率就变低了。第二个问题就是为什么要两个 Survivor 区，一个不行吗？如果只有一个 Survivor 区的话我们来看看会发生什么，Eden 区每次经过垃圾回收后就会将存活的对象放入 Survivor 区，与此同时 Survivor 部分存活已久的对象会进入老年代，这就回导致一个严重的问题--碎片化，如图所示：

![image-20200819211027020](https://pictures.huazai.fun/uPic/image-20200819211027020.png)

所以我们就需要用两个 Survivor 区来解决这个问题，每次 Minor GC 时都将 Eden 区和一个 Survivor区中存活的对象复制到另一个 Survivor区中，然后清空原有两个区域，两个 Survivor区轮流互换，这样就解决了碎片化问题，如图

![image-20200819211805285](https://pictures.huazai.fun/uPic/image-20200819211805285.png)

